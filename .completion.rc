#!/bin/bash
CTRLFMODE="path"
CTRLCACHE="/home/anon/Desktop/"
function ctrl_f_mode(){
	read -n 1 M
	case $M in
		p) CTRLFMODE="path";;
		u) CTRLFMODE="user";;
		o) CTRLFMODE="opt";;
		c) CTRLFMODE="cmd" ;;
		v) CTRLFMODE="var" ;;
		*) CTRLFMODE="path";;
	esac
	env echo -e "\033[1mctrl-f mode: \"\033[0m${CTRLFMODE}\""
}
function echo_readline_line(){
	PS1_CLEANED=${PS1//\\\[/}
	PS1_CLEANED=${PS1_CLEANED//\\\]/}
	env echo -e "${PS1_CLEANED}${1:0:${2}}\033[45m \033[0m${1:${2}}"
	#env echo -e "${PS1}${1:0:${2}}\033[45m \033[0m${1:${2}}"
}
function ctrl_f(){
	# Show command and substitution position
		echo_readline_line "${READLINE_LINE}" "${READLINE_POINT}"
	# Get narrowing substring
		PX=""
		PX=$(lastWord "${READLINE_LINE:0:${READLINE_POINT}}")
		PXL=${#PX}
		PX="$(echo $PX)"
		#echo "'$PX'"
	# Decide possible completions and use fzf for selection
		case $CTRLFMODE in
			"path")
				if [ "$PX" != "" ]; then
					STR=$(find "$PX" 2> /dev/null | fzf --multi=1)
				else
					STR=$(find 2> /dev/null | fzf --multi=1)
				fi
				;;
			"opt")
				echo "Not implemented."
				return
				#get command
				#check catche
				#parse
				;;
			"user")
				if [ "$PX" != "" ]; then
					STR="$(compgen -u ${PX} | fzf --multi=1)"
				else
					STR="$(compgen -u | fzf --multi=1)"
				fi
				;;
			"cmd")
				if [ "$PX" != "" ]; then
					STR="$(compgen -c ${PX} | uniq | fzf --multi=1)"
				else
					STR="$(compgen -c | uniq | fzf --multi=1)"
				fi
				;;
			"var")
				if [ "$PX" != "" ]; then
					STR="$(compgen -v ${PX} | fzf --multi=1)"
				else
					STR="$(compgen -v | fzf --multi=1)"
				fi
				;;
		esac
	# Remove ${PX}
		STR="${STR:${#PX}}"
	# Write $READLINE_LINE
		[ -z "$STR" ] && return
		if [ "$CTRLFMODE" == "path" ]; then	# if paths -> quote
			READLINE_LINE="${READLINE_LINE:0:$(expr ${READLINE_POINT} - ${PXL})}\"${PX}${STR}\"${READLINE_LINE:${READLINE_POINT}}"	# start_til_px + '"' + px + str '"' + rest
			READLINE_POINT=$(expr ${READLINE_POINT} + ${#PX} + ${#STR} + 2)	# +2 for the '"'s
		else
			READLINE_LINE="${READLINE_LINE:0:$(expr ${READLINE_POINT} - ${PXL})}${PX}${STR}${READLINE_LINE:${READLINE_POINT}}"	# start_til_px + px + str + rest
			READLINE_POINT=$(expr ${READLINE_POINT} + ${#PX} + ${#STR})
		fi
}

bind -x '"\C-e": ctrl_f_mode'
bind -x '"\C-f": ctrl_f'
